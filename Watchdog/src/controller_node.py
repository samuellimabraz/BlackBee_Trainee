#!/usr/bin/env python

import rospy
from std_msgs.msg import Empty, UInt8, Int16
from geometry_msgs.msg import Twist

from threading import Timer

from modules.BebopModule import Bebop


class Controller:
    """
    Drone control through events generated by detection
    """
    def __init__(self) -> None:
        self.drone = Bebop()
        
        self.current_hand_event = -2 # The last hand event
        self.timer = None # timer for debounce

    def face_follower_control(self, event):
        rospy.loginfo(f"Face event: {event.data}")
        if event == 1:
            # YAW LEFT
            pass
        elif event == 2:
            # YAW RIGHT
            pass
        elif event == 3:
            # UP
            pass
        elif event == 4:
            # DOWN
            pass
    
    def face_distance_control(self, dist):
        rospy.loginfo(f"Face depth: {dist.data}")
                
    def hand_callback(self, event):
        """
        Receives the gesture detection event, if the event remains for 1.5sec, motion publication is performed
        """
        if self.current_hand_event != event.data:
            # New event detected, cancel previous timer (if any).
            if self.timer is not None:
                self.timer.cancel()

            if event.data != -1:
                self.timer = Timer(1.5, self.perform_hand_action)
                self.timer.start()

        self.current_hand_event = event.data

    def perform_hand_action(self):
        """
        Performs the movement of the recognized event
        """
        
        rospy.loginfo(f"Hand event: {self.current_hand_event}")
        if (self.current_hand_event == 0) and (not self.drone.flying):
            self.drone.takeoff()
            rospy.sleep(3)
        elif self.current_hand_event == 1:
            pass
        elif self.current_hand_event == 2:
            pass
        elif self.current_hand_event == 3:
            pass
        elif self.current_hand_event == 4:
            pass
        elif self.current_hand_event == 5:
            pass
        elif self.current_hand_event == 6:
            self.drone.wave()

    def start(self):
        rospy.init_node("controller_node", anonymous=True)

        rospy.Subscriber("hand_event", Int16, self.hand_callback)
        rospy.Subscriber("face_depth", Int16, self.face_distance_control)
        rospy.Subscriber("face_event", UInt8, self.face_follower_control)
        rospy.spin()


def main():
    control = Controller()
    control.start()


if __name__ == "__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass

# # Parâmetros do controle PID
# Kp_linear = 0.00004  # Constante proporcional do controle PID para linear.x
# Kd_linear = 0.01  # Constante derivativa do controle PID para linear.x
# Kp_angular = 0.01  # Constante proporcional do controle PID para angular.z
# Kd_angular = 0.02  # Constante derivativa do controle PID para angular.z

# target_area = 30000  # Área desejada para a pessoa
# area_tolerance = 4000  # Tolerância para considerar movimento linear
# target_center = 320  # Coordenada x do centro desejado
# center_tolerance = 50  # Tolerância para considerar a pessoa centrada

# prev_error_area = 0
# prev_error_yaw = 0


# def control(img, imgOut):
#     area, center = detectPeople(img, imgOut)
#     event = detectHand(img, imgOut)

#     if center:
#         # Controle PID para movimento linear (linear.x)
#         error_area = target_area - area

#         control_linear = Kp_linear * error_area + Kd_linear * (
#             error_area - prev_error_area
#         )

#         # Controle PID para Yaw (angular.z)

#         error_yaw = center[0] - img.shape[1] // 2

#         control_angular = Kp_angular * error_yaw + Kd_angular * (
#             error_yaw - prev_error_yaw
#         )

#         # Ajustar os valores de controle dentro dos limites dos tópicos
#         control_linear = max(min(control_linear, 1.0), -1.0)
#         control_angular = max(min(control_angular, 1.0), -1.0)

#         # Atualizar os erros anteriores
#         prev_error_area = error_area
#         prev_error_yaw = error_yaw

#         if abs(error_area) > area_tolerance:
#             # err > 0 : forward; err < 0 : backward
#             vel.linear.x = control_linear

#         if abs(error_yaw) > center_tolerance:
#             vel.angular.z = control_angular

#     cmd_pub.publish(vel)
